---
date: 2024-02-11
today:
---
## 알고리즘
- [BOJ - 1043](https://www.acmicpc.net/problem/1043) : 유니온 파인드 문제. 쉽게 생각하면 될 것을 어렵게 생각해서...
- [BOJ - 2638](https://www.acmicpc.net/problem/2638) : 오래 걸릴 것 같다고 혼자 판단하지 말고, 시간복잡도를 미리 계산해보든 구현을 먼저 하든 행동하자

---


## 테스트코드

테스트 코드 작성 방법 관련 유튜브 영상을 보다 아래 설명을 듣고, 곰곰히 생각해봤다.
> 해당 객체가 본인의 책임을 다하지 않으면 그 책임은 다른 객체로 넘어간다.

남의위키에서 생성하는 설문은 답변의 유형이 여러가지이다보니, 클라에서 준 데이터를 어떻게 검증할지 고민이 많았다.
처음에는 `SurveyService`에서 해당 로직을 검증하려고 했었다. 일단 DB에 저장하는 로직을 작성하고 나서 테스트코드를 작성하려니 책임이 너무 많다는 생각이 들었다.
SurveyService에서는 "설문" 자체에 대한 책임만 가지고 있어야 하지, 설문의 "답변"은 다른 문제가 아닌가? 하는 생각.

그렇게 `SurveyAnswerService`를 나누었다.
이렇게 나누고 나니 설문의 답변에만 집중할 수 있어 로직을 검증하기 더 편해졌다(고 믿는다)

검증해야 할 부분이
1. 문항의 유형별로 받을 수 있는 답변 유형 이 올바른지
2. 답변의 유형이 미리 정의해놓은 선지일 경우 해당 Option이 존재하는지
3. 그 Option이 해당 Question의 선지가 맞는지
이 정도인데, 문항별로 답변별로 다 다를 수 있어 까다로웠다.

자바 테스트코드 강의에서 들었던 것을 끄집어내..
작은 것부터 하나씩 추가해보았다.

1번)
문항 타입과 답변 타입 모두 enum으로 정의해놨었고, 문항 타입별로 받을 수 있는 답변 타입들이 정해져 있다. 그래서 문항 타입 enum에 받을 수 있는 답변 타입 리스트를 추가했고, 포함하고 있는지 확인하는 메소드도 추가해줬다. SurveyAnswer DTO를 만들었고, 이 부분 검증하는 로직을 생성자에 넣어 인스턴스를 생성할 때 검증하도록 했다.


2번)
답변의 타입이 `"OPTIONAL"`일 경우, `answer` 필드는 무조건 optionId이어야 하고 또 DB에 실제로 존재해야 한다. DB를 조회하는 부분이라 서비스 레이어에서 검증했다.


3번)
이 부분도 DB를 조회해야 하기 때문에 서비스 레이어에서 진행했다.

여기까지 수정하면서 고민되었던 부분들이 있다.
1. DTO <-> Entity 변환이 꽤나 잦게 일어나는데, 변환하는 메소드를 어디에 두어야 할까?
	DTO는 말  그대로 데이터 전송을 위한 용도라서 두기 좀 그렇고, Entity는 말 그대로 엔티티를 나타내는 용도라서 두기 애매하다고 생각했다. 둘 다 어떤 비즈니스 로직을 수행하기 위한 곳은 아니라고 판단했고, Model 클래스를 생성했다.
	`List<SurveyAnswer>`만 필드로 가지고 있는 `SurveyAnswers`이다. `SurveyAnswer` 클래스 정의를 Model 안에 두고 private으로 감춰버리니, 비즈니스 로직이 한 군데로 모였다.
2. 서비스에서 다른 서비스를 의존해도 될까?
	이전에도 했던 고민인데, 아직 풀리지 않았다. 이제까지는 단순히 DB를 조회하는 일밖에 없어서 서비스를 의존하지 않았지만, 이번에 `SurveyAnswerService`를 만들면서 `SurveyService`가 서비스를 의존하게 되었다. `SurveyAnswerService`가 `SurveyService`를 의존하지 않으면 순환참조가 일어나지 않겠지만, 같은 레이어에 있으니 조심하지 않으면 충분히 발생할 수 있는 문제이다.
	리서칭하다가 찾은 글에서는, 이를 위해서 서비스가 의존하는 작은 계층을 하나 더 만드는 것은 이름이 다른 서비스를 만드는 것과 뭐가 다르냐는 질문에 이해가 되어서 일단 두기로 했다. 나중에 코드리뷰하면서 논의해봐야지.



Mock 객체를 왜 사용하나 이제까지 이해가 잘 안됐었는데, 객체가 하는 "동작"에 집중하니 조금 이해가 되었다.
이전에 연습했던 코드는 repository, service 모두 mock 객체로 구현했었다. 이게 잘못되었다는 것을 알았다.

특히 2번처럼 DB에 존재하는지 확인해야 하는 일이 서비스가 책임을 지는 것이라고 생각했는데, 아니었다. 존재를 확인하는 일은 repository의 역할이었다.
서비스는 repository의 답변에 따라서 그에 맞는 행동을 하면 되는 것이었다.

그러니까 서비스는 repository에 실제로 데이터가 있는지 없는지는 중요하지 않고,

> 있을 땐 이렇게 하고, 없을 때 이렇게 하고

가 중요한 것이었다.

이렇게 생각하니 그제서야 예제 코드들이 이해가 되었다. 
"repository에서 호출할 메소드가 어떤 걸 반환할지 미리 정해두고, 서비스가 그에 따라서 동작하는지 확인하면 되는 것"

이전에는 이 말이 왜 이렇게 어렵게 느껴졌을까ㅠㅠ



