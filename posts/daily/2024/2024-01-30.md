---
date: 2024-01-30
today: JPA의 N+1 문제를 경험했다.
---
## 알고리즘
- [BOJ - 11054](https://www.acmicpc.net/problem/11054) : 가장 긴 바이토닉 부분 수열
- [BOJ - 11404](https://www.acmicpc.net/problem/11404) : 플로이드 - 플로이드 워셜 알고리즘

### 플로이드-워셜 알고리즘
모든 노드 간 최단 경로를 구하는 알고리즘
시간복잡도 O(N^3) 임.



---

# Spring
## JPA

### N+1를 직접 경험하는 상황이 왔다.

user가 instrument 여러 개를 priority로 가질 수 있는 상황이다.
instrument를 findAll 조회를 하니, 

아래와 같은 것을 예상했지만
```sql
select * from instrument
```

현실은 N개가 더 조회되었다.
```sql
Hibernate: select * from instrument
Hibernate: select * from user_instrument left join user on user.id=user_id where instrument_id=?
Hibernate: select * from user_instrument left join user on user.id=user_id where instrument_id=?
Hibernate: select * from user_instrument left join user on user.id=user_id where instrument_id=?
Hibernate: select * from user_instrument left join user on user.id=user_id where instrument_id=?
Hibernate: select * from user_instrument left join user on user.id=user_id where instrument_id=?
Hibernate: select * from user_instrument left join user on user.id=user_id where instrument_id=?
Hibernate: select * from user_instrument left join user on user.id=user_id where instrument_id=?
Hibernate: select * from user_instrument left join user on user.id=user_id where instrument_id=?
```


## Filter...와 ExceptionHandler 순서.. 

특정 path를 제외한 모든 요청은 유효한 JWT를 헤더로 가지지 않으면 Filter에서 걸러지게 하고 싶었다.
![[Pasted image 20240130142720.png]]