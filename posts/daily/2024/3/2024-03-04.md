---
date: 2024-03-04
today:
---
## 알고리즘
- ☑️ [BOJ - 20188](https://www.acmicpc.net/problem/20188) : 등산 마니아, 관점을 바꿔서 생각해야 했던 문제
- [BOJ - 1943](https://www.acmicpc.net/problem/1943) 

---

# 우아한 객체지향
세미나 영상 : https://www.youtube.com/watch?v=dJ5C4qRqAgA

핵심은 "의존성을 어떻게 관리하느냐?"
같이 변경되는 같이 넣고, 같이 변경되지 않는 코드는 따로 넣어야 한다.

의존성 : 변경에 의해서 영향을 받을 수 있는 가능성

## 클래스 의존성의 종류

1. Association : 연관 관계
A에서 B로 **영구적으로** 이동할 수 있어요.
내지, A에서 B 객체를 참조하고 있다.

어떤 객체에서 어떤 객체로 빈번하게 교류가 발생해서, 이 경로를 영구적으로 두어야 할 경우이다.
어떤 일이 있어도 A와 B는 함께 해야 할 운명으로 만들어버리기 때문에, 굉장히 조심해야 한다.

```java
class A {
	private B b;
}
```

2. Dependency : 의존 관계
협력이 생기는 그 순간에 **일시적으로** 관계를 맺고 헤어진다.
파라미터, 리턴타입, 지연변수 등

```java
class A {
	public B func(B b) {
	}
}
```

3. Inheritance : 상속 관계
구현이 바뀌면 영향을 받을 수 있는 것

```java
class A extends B {
}
```


4. Realization : 실체화 관계
interface의 시그니처가 변경되었을 때만 영향을 받는 것


```java
class A implements B {
}
```

![[Pasted image 20240304184911.png]]

## 좋은 의존성을 관리하기 위한 규칙

1. 양방향 의존성을 피하라
Bi-Directional 에서 Uni-Directional 로 변경해야 한다.

2. 다중성이 적은 방향을 선택하라

AS-IS : 일대다
```java
class A {
	private Collection<B> bs;
}

class B{
}
```

To-Be : 다대일
```java
class A {
}

class B{
	private A a;
}
```

3. 의존성이 필요없다면 제거하라
4. 패키지 사이의 의존성 사이클을 제거하라


> 관계의 방향 = 협력의 방향 = 의존성의 방향


## 연관관계 = 탐색가능성

A -> B 라면, 
=> A가 뭔지 알면 A를 통해서 B를 찾을 수 있다.

**구현 방법**
1. 객체 참조를 이용(멤버 필드)
2. ~

## 설계 개선하기

### 2가지 문제
1. 객체 참조로 인한 결합도 상승 : 모든 것을 연결시켜버림
	- 성능 문제 - 어디까지 조회할 것인가?
	- 객체 그룹의 조회 경계가 모호
	- 수정 시 도메인 규칙을 함께 적용할 경계는?
	- 트랜잭션 경계는 어디까지인가? - 객체 참조는 이 트랜잭션 경계를 생각하지 않게 만들어버린다.
2. 패키지 의존성 사이클

	![[Pasted image 20240304191543.png]]

	패키지의 사이클이 발생
	![[Pasted image 20240304191703.png]]




## 연관관계 다시 살펴보기
필요에 따라 연관관계를 끊어버려야 한다.
강한 결합을 Repository를 통해 약한 결합으로 변경한다.
Order에서 `Shop` Entity를 모두 가지고 있었다면, `shopId`만 가지게 한 후 Repository를 통해서 접근을 제어한다.

**어떤 객체들을 묶고 어떤 객체들을 분리할 것인가?**
1. 함께 생성되고 함께 삭제되는 객체들을 함께 묶기
2. 도메인 제약사항을 공유하는 객체들을 함게 묶기
3. 가능하면 분리하라

경계 안의 객체는 참조를 이용해 접근, 경계 밖의 객체는 ID를 이용해 접근한다.
그리고 Repository를 통해서 탐색한다.

> 조회 경계 = 트랜잭션 단위 = 객체 경계

이 그룹 단위의 영속성 저장소 변경 가능하다.
mongoDB에 저장할 때도 이 단위로 하면 된다. 
Document 단위로 한 번에 가져오고, 한 번에 써야 한다.


### 객체를 직접 참조하는 로직을 다른 객체로 옮기기

#### 실행 순서가 관련 없는 경우 : Validation
로직의 결합도를 증가시키고 명확하게 순서를 보여주고 싶을 때 사용

직접 참조를 없앤 후, 컴파일 에러가 발생 -> validation 로직을 하나의 클래스로 모아서 해당 객체를 가져다 씀
=> 절차 지향


**장점**
- 객체지향에서 validation 로직은 여러 군데 찢어져 있어서 쫓아다니면서 보기 어려웠는데, 한 번에 볼 수 있어짐. validation이 관련 객체 안에 있으면 결합도는 높이지만 응집도는 낮추게 된다.
- 도메인 객체 안에 validation과 도메인 비즈니스 로직이 함께 들어가 있었는데 validation 코드를 제거하면서 응집도 높은 객체가 됨


### Domain Event 퍼블리싱

느슨한 결합을 유지하고 싶을 때 사용

![[Pasted image 20240304195130.png]]

직접 구현하는 게 좋다. 
Spring 에서 제공하는 것 중에는 `AbstractAggregateRoot` 클래스가 있고, 상속받으면 `registerEvent` 메소드를 사용할 수 있다.
이 도메인 이벤트를 사용할 경우 DB에 commit이 될 때 이 Event를 스프링이 발행시켜준다.

Event Handler를 통해서 이벤트 처리할 수 있다.
![[Pasted image 20240304195338.png]]





### 1. 중간 객체를 이용한 의존성 사이클 끊기
![[Pasted image 20240304191838.png]]

추상화된 중간 객체를 중간에 껴서 의존성을 끊었다.
추상화 : 잘 변하지 않는 것. interface나 abstract 같은 것들이 아니다. 개념적인 용어이다.


이 방법의
- 장점 
	- 재사용성이 증가함 - 카트에서도, 주문에서도 이 객체를 사용할 수 있다.
- 단점


### 2. 의존성 역전

interface나 추상 클래스를 사용해서 의존성을 역전한다.


### 3. 패키지 분리

의존성 사이클이 발생할 때, 새로운 패키지로 분리하는 것에 대해 고민해볼 수 있다.
여러 도메인의 로직이 특정 패키지에 속해있을 때 사이클이 발생한다.

이 때 패키지를 분리하면 사이클을 없앨 수 있다.

클래스 단위 의존성 그래프를 그려본 후, 도메인 단위 의존성 그래프를 그려보면 사이클이 존재하는 것을 발견할 수도 있다.

![[Pasted image 20240304195927.png]]

이를 도메인 이벤트로 분리하고, 도메인 별로 패키지를 분리한 후에는
![[Pasted image 20240304200046.png]]

이렇게 되면 시스템을 찢어내기 쉽고, 시스템 간의 메시지 통신이 가능하도록 처리할 수 있다.

![[Pasted image 20240304200134.png]]


