---
date: 2024-04-02
today: 어플리케이션에 맞게 적절한 스레드풀을 설정하는 것이 중요하다
---
## 그럼 @Async를 사용할 때 어떤 스레드풀을 사용하면 좋을까?

어제 일단 디폴트 executor인 `SimpleAsyncTaskExecutor`은 스레드 생성과 관린 측면상 비효율적이기 때문에 사용하지 않는 게 좋겠다는 판단을 하였으니, 다른 대안을 찾아보았다.

크게 2가지의 선택지가 있다. 2개 모두 `TaskExecutor` 인터페이스를 구현하고 있는 구현체이다.

1. **ThreadPoolTaskExecutor**
	- ThreadPoolExecutor의 래핑 버전
	- 스레드 풀의 크기, 큐 용량 등을 세부적으로 설정할 수 있어서, 애플리케이션 환경에 따라 유연하게 대응 가능하다.
2. **ConcurrentTaskExecutor**
	- 기존 `Executor` 인스턴스의 재사용에 초점을 맞춘 구현체이다.
	- 스레드 풀에 세밀한 설정이 필요하지 않거나, 다른 라이브러리의 호환성을 위해 특정 `executor` 구현을 사용해야 할 때 적합하다.


보통은 `ThreadPoolTaskExecutor`를 사용하는 듯 하다.

그럼 `ThreadPoolTaskExecutor`를 선택했을 때, 또 고민해야 하는 지점은 세부 설정들이다.
스레드 풀 크기, 최대 스레드 수, 큐 용량 등을 어떻게 설정해야 할까?

- 스레드 풀 크기 : 처음 스레드 풀이 생성될 때 생성되는 스레드의 개수(스레드 풀이 유지해야 할 최소 스레드 수)
- 최대 스레드 수 : 스레드 풀이 확장될 수 있는 최대 한계
- 큐 용량 : 스레드 풀에 있는 스레드가 모두 사용 중일 때, 대기할 작업의 최대 수
- keepAliveTime : 스레드 풀이 corePoolSize를 초과하는 스레드를 유지하는 시간. 

만약 큐 용량이 모두 찼다면 스레드 풀 크기를 최대 스레드 수까지 늘리게 된다.
이후 `keepAliveTime` 동안 추가 스레드들이 할당받은 작업이 없으면 이 스레들은 종료된다.

추가 스레드가 종료된다고 해서 기존에 스레드 풀에 있던 스레드들이 더 높은 우선순위를 가지는 것인가? 했는데 그건 아니고.
정확히는 추가 스레드들이 종료되는 것이 아니라, `keepAliveTime` 동안 작업을 할당 받지 않은 스레드를 대상으로 종료 여부를 정한다고 함.

어떤 값으로 선택하면 좋을지는 실제 테스트를 해보면서 정해야 할 듯 ... 하다?

테스트툴을 공부할 타이밍이 온 것인가..

